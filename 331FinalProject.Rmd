---
title: "STAT 331 Final Project"
author: "Maxine, Estella, Judy, Weiwei"
date: "04/12/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Requirement of the project 
Your 7â€“10 page report must contain the following components: 

- 1. Summary:
A maximum of 200 words describing the objective of the report, an overview of the statistical analysis, and summary of the main results.

- 2. Objective:
Describe your goals for the analysis.

- 3. Exploratory Data Analysis:
Conduct exploratory data analyses: report summary statistics, visualize data (histograms, scatter plots, etc.). Report on any interesting findings and comment on how these inform the rest of your analysis.

- 4. Methods:
Describe your statistical analysis: What is your model? Did you use any transformations or extensions of the basic multiple linear regression model? How did you select a model? Does the model fit the data well? Are the necessary assumptions met? Be sure to explain and justify your decisions.

- 5. Results:
Report on the findings of your analysis

- 6. Discussion:
Comment on your findings/conclusions; describe any limitations of your analysis.


# 1. Summary
A maximum of 200 words describing the objective of the report, an overview of the statistical analysis, and summary of the main results.

# 2. Objective 

The goal of this project is to analyze the pollutants.csv data and write a report on your analysis. The specific goals of your analysis are up to you to decide.

# 3. Exploratory Data Analysis
Conduct exploratory data analyses: report summary statistics, visualize data (histograms, scatter plots, etc.). Report on any interesting findings and comment on how these inform the rest of your analysis.

can use this as a tutorial https://r4ds.had.co.nz/exploratory-data-analysis.html


Take a peak at the first 5 entries
```{r dataset}
# CHANGE ABSOLUTE PATH
# setwd("~/Desktop/stat341/R331project/data")
# setwd("~/School/4A/STAT 331/R331project/data")
# setwd("~/Desktop/R331project/data")
# setwd("C:/Users/huawei/Desktop/R331project/data")

pollutants_raw <- read.csv("pollutants.csv", header = TRUE)
head(pollutants_raw)

summary(pollutants_raw)
```


```{r cleandataset}
# Mxn's work
# clean the pollutants dataframe
pollutants <- subset(pollutants_raw , select = -X)

# deal with categorical data

# 1 = Less Than 9th Grade or 9-11th Grade (Includes 12th grade with no diploma) 
# 2 = High School Grad/GED or Equivalent
# 3 = Some College or AA degree
# 4 = College Graduate
edu_factor=factor(pollutants$edu_cat)

# 1 = Other Race (Including Multi-Racial);
# 2 = Mexican American; 
# 3 = Non-Hispanic Black; 
# 4 = Non-Hispanic White
race_factor=factor(pollutants$race_cat, 
                   labels = c("Other", "Mexican", "Black", "White"))

# 0 = does not currently smoke; 
# 1 = currently smokes
smoke_factor=factor(pollutants$smokenow, labels = c("Non-Smoker", "Smoker"))

# 0 = female, 1 = male
gender_factor=factor(pollutants$male, labels = c("female", "male"))


pollutants$edu_cat = edu_factor
pollutants$race_cat = race_factor
pollutants$smokenow = smoke_factor
pollutants$male = gender_factor

head(pollutants)
summary(pollutants)
```

## Get the names of Covariates
```{r covariatenames}
names(pollutants)
```
Note that "edu_cat", "race_cat", "male", "smokenow" are categorical data. 

```{r histograms}
# Mxn's work
# put bargraphs for categorical data onto one picture
par(mfrow=c(2,2))

plot(edu_factor, 
     main="Distribution of Education",
     xlab="Education Level Count")

plot(race_factor, 
     main="Distribution of Race",
     xlab="Race Count")

plot(smoke_factor, 
     main="Distribution of Current Smokers",
     xlab="Smokers Count")

plot(gender_factor, 
     main="Distribution of Gender",
     xlab="Gender Count")
```
```{r boxplots}
# Mxn's work

# PC 1-6
boxplot(pollutants[, 3:8])

# PC 7-11
boxplot(pollutants[, 9:13])

# Doxin
boxplot(pollutants[, 14:16])

# Furan
boxplot(pollutants[, 17:20])
```

```{r linearity}
# Judy's work Part 1
# testing non-linearity in SLR
# if for any covariate, residual vs x for M1 has a pattern and
# residual vs x for M2 seems random, then y has a nonlinear
# relationship with with x.
# M1: fitting y to x
# M2: fitting y to x^2

par(mfrow=c(1, 3))
outcome <- pollutants$length
check <- function(x) {
  M1 <- lm(outcome ~ x)
  print(paste("residual for M1: ", sigma(M1)))
  M2 <- lm(outcome ~ x + I(x^2))
  print(paste("residual for M2: ", sigma(M2)))
  plot(x, M1$residual)
  plot(x, M2$residual)
  plot(x, outcome)
}

list <- list(pollutants$ageyrs, pollutants$yrssmoke,
             pollutants$BMI, pollutants$ln_lbxcot,
             pollutants$whitecell_count, pollutants$lymphocyte_pct, 
             pollutants$monocyte_pct, pollutants$eosinophils_pct, 
             pollutants$basophils_pct, pollutants$neutrophils_pct)
for (column in list) {
  check(column)
}
```

```{r plotlinearity}
# Judy's work Part 2
# testing non-linearity in MLR
library(car)
M <- lm (length ~ ., data=pollutants)
avPlots(M)
```

```{r pcbcorrelations}
# Estella's work 1
library(corrplot)
library(ggplot2)

POP_PCB = c("POP_PCB1", "POP_PCB2","POP_PCB3", "POP_PCB4",
            "POP_PCB5", "POP_PCB6","POP_PCB7", "POP_PCB8",
            "POP_PCB9", "POP_PCB10", "POP_PCB11")

POP_PCB_data <- pollutants [, POP_PCB]
cc = cor(POP_PCB_data , method = "spearman")

# cluster my POP_PCB so that those with similar patterns
# of correlation coefficients are closer together.
# https://jkzorz.github.io/2019/06/11/Correlation-heatmaps.html
corrplot(cc, tl.col = "black", order = "hclust", hclust.method = "average",
         addrect = 4, tl.cex = 0.7)
```

```{r dioxin_correlations}
# Weiwei's work Part 1
POP_dioxin = c("POP_dioxin1", "POP_dioxin2","POP_dioxin3")
POP_dioxin_data <- pollutants [, POP_dioxin]

# cluster my POP_dioxin so that those with similar patterns
# of correlation coefficients are closer together.
cc.dioxin = cor(POP_dioxin_data , method = "spearman")
corrplot(cc.dioxin, tl.col = "black", order = "hclust",
         hclust.method = "average", addrect = 3, tl.cex = 0.7)
```

```{r furan_correlations}
# Weiwei's work Part 2
POP_furan = c("POP_furan1", "POP_furan2","POP_furan3","POP_furan4")
POP_furan_data <- pollutants [, POP_furan]

# cluster my POP_dioxin so that those with similar patterns
# of correlation coefficients are closer together.
cc.furan = cor(POP_furan_data , method = "spearman")
corrplot(cc.furan, tl.col = "black", order = "hclust",
         hclust.method = "average", addrect = 4, tl.cex = 0.7)
```


```{r pcbinteractions}
# Estella's work 3
f <- as.formula(
  paste("length", paste("(", paste(POP_PCB, collapse = "+"), ")^2"), sep="~"))

m_pcb <- lm(f, data = pollutants)
summary(m_pcb)
```

```{r dioxin_interactions}
f_dioxin <- as.formula(
  (paste("length", paste("(", paste(POP_dioxin, collapse = " + "), ")^2"), sep = " ~")))
m_dioxin <- lm(f_dioxin, data = pollutants)
summary(m_dioxin)
```

```{r furan_interactions}
# interaction in furan
f_furan <- as.formula(
  (paste("length", paste("(", paste(POP_furan, collapse = " + "), ")^2"), sep = " ~")))

m_furan <- lm(f_furan, data = pollutants)
summary(m_furan)
```

```{r selectinteractions}
# Estella's work 4 
# setting threshold of pvalue to be 0.05 and assess possible interaction terms
pvalues <- summary(m_pcb)$coefficients[,4]
p_threshold = 0.05
selected <- which(pvalues <= p_threshold)
names(selected)
```

# 4. Methods:
Describe your statistical analysis: What is your model? Did you use any transformations or extensions of the basic multiple linear regression model? How did you select a model? Does the model fit the data well? Are the necessary assumptions met? Be sure to explain and justify your decisions.

```{r splitdata}
train_data <- pollutants[1:600,]
test_data <- pollutants[601:nrow(pollutants),]
```

```{r buildmodel}
#stepwise parameters selection without any interaction terms
M0 <- lm(length ~ 1, data = train_data) # minimal model
Mfull <- lm(length ~ ., data= train_data)

## 2 corresponds to AIC
## log(n) corresponds to BIC

# stepwise AIC
Mstart <- lm(length ~ ., data= train_data)
system.time({
  MAIC <- step(object = Mstart,
               scope = list(lower = M0, upper = Mfull),
               direction = "both", trace = 0, k = 2)
})

#stepwiseBIC
system.time({
  MBIC <- step(object = Mstart,
               scope = list(lower = M0, upper = Mfull),
               direction = "both", trace = 0, k = log(nrow(train_data)))
})

#stepwiseB_Adjusted R2
MAIC
MBIC
```

```{r buildmodelinteractions}
# stepwise parameters selection with any interaction terms
M0 <- lm(length ~ 1, data = train_data) # minimal model

# tail to remove length column
single <- paste(tail(colnames(train_data),-1), collapse = " + ")
# tail to remove intercept column
interaction <- paste(tail(names(selected),-1), collapse = " + ")
f_interaction <- as.formula(
  paste("length", paste("(", single,"+", interaction, ")"), sep = " ~"))

Mfull <- lm(f_interaction, data = train_data)
Mstart <- lm(f_interaction, data = train_data)

# stepwise AIC
Mstart <- lm(length ~ ., data= train_data)
system.time({
  MAIC_Interaction <- step(object = Mstart,
                           scope = list(lower = M0, upper = Mfull),
                           direction = "both", trace = 0, k = 2)
})

#stepwiseBIC
system.time({
  MBIC_Interaction <- step(object = Mstart,
                           scope = list(lower = M0, upper = Mfull),
                           direction = "both", trace = 0, 
                           k = log(nrow(train_data)))
})

#stepwiseB_Adjusted R2
MAIC_Interaction
MBIC_Interaction
```

```{r testmodels}
# mxn's work
predAIC <- predict(MAIC, newdata=test_data)
predBIC <- predict(MBIC, newdata=test_data)
predAICInteraction <- predict(MAIC_Interaction, newdata=test_data)
predBICInteraction <- predict(MBIC_Interaction, newdata=test_data)

mean((test_data$length - predAIC)^2)
mean((test_data$length - predBIC)^2)
mean((test_data$length - predAICInteraction)^2)
mean((test_data$length - predBICInteraction)^2)
``` 

